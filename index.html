<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Vision: Final + Filters</title>
    <style>
        body { font-family: 'Segoe UI', Roboto, sans-serif; padding: 20px; max-width: 1000px; margin: 0 auto; background-color: #f1f5f9; color: #1e293b; }
        .card { background: white; padding: 25px; border-radius: 12px; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1); margin-bottom: 20px; border: 1px solid #e2e8f0; }
        h1 { margin-top: 0; color: #0f172a; }
        
        /* –ö–Ω–æ–ø–∫–∏ */
        button { background: #3b82f6; color: white; border: none; padding: 10px 20px; border-radius: 6px; font-size: 15px; cursor: pointer; font-weight: 600; transition: 0.2s; }
        button:disabled { background: #cbd5e1; cursor: not-allowed; }
        button:hover:not(:disabled) { background: #2563eb; }
        button.success { background: #10b981; }
        button.secondary { background: #64748b; font-size: 13px; padding: 6px 12px; }

        /* –õ–æ–≥ —ñ –ø—Ä–æ–≥—Ä–µ—Å */
        #log { height: 250px; overflow-y: auto; background: #0f172a; color: #4ade80; padding: 15px; font-family: monospace; border-radius: 8px; margin-top: 20px; font-size: 12px; }
        .progress-container { width: 100%; background: #e2e8f0; height: 10px; border-radius: 5px; margin: 15px 0; overflow: hidden; }
        .progress-fill { height: 100%; background: #3b82f6; width: 0%; transition: width 0.3s; }
        
        /* –§—ñ–ª—å—Ç—Ä–∏ */
        .filter-section { margin-top: 15px; border-top: 1px solid #e2e8f0; padding-top: 15px; }
        .filter-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 8px; max-height: 200px; overflow-y: auto; padding: 10px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0; }
        .filter-item { display: flex; align-items: center; font-size: 13px; }
        .filter-item input { margin-right: 8px; }
        details summary { cursor: pointer; font-weight: bold; color: #3b82f6; margin-bottom: 10px; }

        /* –ú–æ–¥–∞–ª—å–Ω–µ –≤—ñ–∫–Ω–æ */
        #resultModal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); align-items: center; justify-content: center; z-index: 2000; }
        .modal-content { background: white; padding: 20px; width: 85%; height: 85%; border-radius: 10px; display: flex; flex-direction: column; }
        textarea { width: 100%; height: 100%; margin-top: 10px; border: 1px solid #ccc; padding: 10px; resize: none; font-family: monospace; }
        .close-btn { cursor: pointer; align-self: flex-end; padding: 5px 10px; background: #f1f5f9; border-radius: 4px; }
        
        /* –ó–∞–≤–∞–Ω—Ç–∞–∂—É–≤–∞—á –º–æ–¥–µ–ª–µ–π */
        #loadingSection { margin-top: 10px; display: none; }
        .load-bar-bg { width: 100%; background: #e2e8f0; height: 6px; border-radius: 3px; }
        .load-bar-fill { height: 100%; background: #f59e0b; width: 0%; transition: width 0.2s; }
        .load-text { font-size: 12px; color: #64748b; display: flex; justify-content: space-between; margin-bottom: 4px;}
    </style>
</head>
<body>

    <div class="card">
        <h1>üîç AI Vision: Configurable</h1>
        <p>
            1. <b>YOLOS-Tiny:</b> –ü–æ—à—É–∫ –æ–±'—î–∫—Ç—ñ–≤ (–∑ —Ñ—ñ–ª—å—Ç—Ä–æ–º).<br>
            2. <b>ViT-GPT2:</b> –û–ø–∏—Å —Å—Ü–µ–Ω–∏.<br>
            3. <b>NLLB-200:</b> –ü–µ—Ä–µ–∫–ª–∞–¥.
        </p>
        
        <div id="modelStatus" style="font-weight: 600; color: #d97706; background: #fffbeb; padding: 10px; border-radius: 6px;">
            ‚è≥ –û—á—ñ–∫—É–≤–∞–Ω–Ω—è –∑–∞–ø—É—Å–∫—É...
        </div>

        <div id="loadingSection">
            <div class="load-text"><span id="loadName">Loading...</span><span id="loadPct">0%</span></div>
            <div class="load-bar-bg"><div id="loadBar" class="load-bar-fill"></div></div>
        </div>

        <!-- –°–ï–ö–¶–Ü–Ø –§–Ü–õ–¨–¢–†–Ü–í -->
        <div class="filter-section">
            <details open>
                <summary>‚öôÔ∏è –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –∫–ª–∞—Å—ñ–≤ –æ–±'—î–∫—Ç—ñ–≤ (–©–æ —à—É–∫–∞—Ç–∏?)</summary>
                <div style="margin-bottom: 10px;">
                    <button class="secondary" id="selectAllBtn">–û–±—Ä–∞—Ç–∏ –≤—Å—ñ</button>
                    <button class="secondary" id="deselectAllBtn">–ó–Ω—è—Ç–∏ –≤—Å—ñ</button>
                </div>
                <div class="filter-grid" id="filterGrid">
                    <!-- –ß–µ–∫–±–æ–∫—Å–∏ –±—É–¥—É—Ç—å —Ç—É—Ç -->
                </div>
            </details>
        </div>

        <button id="folderBtn" style="margin-top: 20px;" disabled>üìÇ –û–±—Ä–∞—Ç–∏ –ø–∞–ø–∫—É —ñ –ø–æ—á–∞—Ç–∏</button>
    </div>

    <div class="card" id="processingArea" style="display:none;">
        <div style="display: flex; gap: 20px; font-weight: bold; margin-bottom: 10px;">
            <div>–í—Å—å–æ–≥–æ: <span id="totalCount">0</span></div>
            <div>–û–±—Ä–æ–±–ª–µ–Ω–æ: <span id="processedCount">0</span></div>
        </div>
        <div class="progress-container"><div class="progress-fill" id="progressFill"></div></div>
        <div id="log"></div>
        <button id="viewResultsBtn" style="display:none; margin-top: 15px; background: #475569;">üìÑ –î–∏–≤–∏—Ç–∏—Å—è JSON</button>
    </div>

    <div id="resultModal">
        <div class="modal-content">
            <span class="close-btn" id="closeModal">–ó–∞–∫—Ä–∏—Ç–∏</span>
            <textarea id="jsonViewer" readonly></textarea>
        </div>
    </div>

    <script type="module">
        import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2';

        env.allowLocalModels = false;
        env.useBrowserCache = true;

        // --- –°–õ–û–í–ù–ò–ö –ö–õ–ê–°–Ü–í COCO (Eng -> Ukr) ---
        // –¶–µ –¥–æ–∑–≤–æ–ª—è—î –∑–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ –º–µ–Ω—é –º–∏—Ç—Ç—î–≤–æ —ñ –Ω–µ –ø–µ—Ä–µ–∫–ª–∞–¥–∞—Ç–∏ –∫–æ–∂–µ–Ω —Ä–∞–∑ "Tie" —á–µ—Ä–µ–∑ –®–Ü
        const COCO_LABELS = {
            "person": "–ª—é–¥–∏–Ω–∞", "bicycle": "–≤–µ–ª–æ—Å–∏–ø–µ–¥", "car": "–∞–≤—Ç–æ", "motorcycle": "–º–æ—Ç–æ—Ü–∏–∫–ª", "airplane": "–ª—ñ—Ç–∞–∫",
            "bus": "–∞–≤—Ç–æ–±—É—Å", "train": "–ø–æ—Ç—è–≥", "truck": "–≤–∞–Ω—Ç–∞–∂—ñ–≤–∫–∞", "boat": "—á–æ–≤–µ–Ω", "traffic light": "—Å–≤—ñ—Ç–ª–æ—Ñ–æ—Ä",
            "fire hydrant": "–≥—ñ–¥—Ä–∞–Ω—Ç", "stop sign": "–∑–Ω–∞–∫ —Å—Ç–æ–ø", "parking meter": "–ø–∞—Ä–∫–æ–º–∞—Ç", "bench": "–ª–∞–≤–∫–∞",
            "bird": "–ø—Ç–∞—Ö", "cat": "–∫—ñ—Ç", "dog": "—Å–æ–±–∞–∫–∞", "horse": "–∫—ñ–Ω—å", "sheep": "–≤—ñ–≤—Ü—è", "cow": "–∫–æ—Ä–æ–≤–∞",
            "elephant": "—Å–ª–æ–Ω", "bear": "–≤–µ–¥–º—ñ–¥—å", "zebra": "–∑–µ–±—Ä–∞", "giraffe": "–∂–∏—Ä–∞—Ñ–∞", "backpack": "—Ä—é–∫–∑–∞–∫",
            "umbrella": "–ø–∞—Ä–∞—Å–æ–ª—è", "handbag": "—Å—É–º–∫–∞", "tie": "–∫—Ä–∞–≤–∞—Ç–∫–∞", "suitcase": "–≤–∞–ª—ñ–∑–∞", "frisbee": "—Ñ—Ä—ñ–∑–±—ñ",
            "skis": "–ª–∏–∂—ñ", "snowboard": "—Å–Ω–æ—É–±–æ—Ä–¥", "sports ball": "–º'—è—á", "kite": "–ø–æ–≤—ñ—Ç—Ä—è–Ω–∏–π –∑–º—ñ–π", "baseball bat": "–±–∏—Ç–∞",
            "baseball glove": "—Ä—É–∫–∞–≤–∏—Ü—è", "skateboard": "—Å–∫–µ–π—Ç", "surfboard": "—Å–µ—Ä—Ñ", "tennis racket": "—Ä–∞–∫–µ—Ç–∫–∞",
            "bottle": "–ø–ª—è—à–∫–∞", "wine glass": "–∫–µ–ª–∏—Ö", "cup": "—á–∞—à–∫–∞", "fork": "–≤–∏–¥–µ–ª–∫–∞", "knife": "–Ω—ñ–∂", "spoon": "–ª–æ–∂–∫–∞",
            "bowl": "–º–∏—Å–∫–∞", "banana": "–±–∞–Ω–∞–Ω", "apple": "—è–±–ª—É–∫–æ", "sandwich": "—Å–µ–Ω–¥–≤—ñ—á", "orange": "–∞–ø–µ–ª—å—Å–∏–Ω",
            "broccoli": "–±—Ä–æ–∫–æ–ª—ñ", "carrot": "–º–æ—Ä–∫–≤–∞", "hot dog": "—Ö–æ—Ç-–¥–æ–≥", "pizza": "–ø—ñ—Ü–∞", "donut": "–ø–æ–Ω—á–∏–∫",
            "cake": "—Ç–æ—Ä—Ç", "chair": "—Å—Ç—ñ–ª–µ—Ü—å", "couch": "–¥–∏–≤–∞–Ω", "potted plant": "–≤–∞–∑–æ–Ω", "bed": "–ª—ñ–∂–∫–æ",
            "dining table": "—Å—Ç—ñ–ª", "toilet": "—Ç—É–∞–ª–µ—Ç", "tv": "—Ç–µ–ª–µ–≤—ñ–∑–æ—Ä", "laptop": "–Ω–æ—É—Ç–±—É–∫", "mouse": "–º–∏—à–∞",
            "remote": "–ø—É–ª—å—Ç", "keyboard": "–∫–ª–∞–≤—ñ–∞—Ç—É—Ä–∞", "cell phone": "—Ç–µ–ª–µ—Ñ–æ–Ω", "microwave": "–º—ñ–∫—Ä–æ—Ö–≤–∏–ª—å–æ–≤–∫–∞",
            "oven": "–ø—ñ—á", "toaster": "—Ç–æ—Å—Ç–µ—Ä", "sink": "—Ä–∞–∫–æ–≤–∏–Ω–∞", "refrigerator": "—Ö–æ–ª–æ–¥–∏–ª—å–Ω–∏–∫", "book": "–∫–Ω–∏–≥–∞",
            "clock": "–≥–æ–¥–∏–Ω–Ω–∏–∫", "vase": "–≤–∞–∑–∞", "scissors": "–Ω–æ–∂–∏—Ü—ñ", "teddy bear": "–≤–µ–¥–º–µ–¥–∏–∫", "hair drier": "—Ñ–µ–Ω",
            "toothbrush": "—â—ñ—Ç–∫–∞"
        };

        // –ï–ª–µ–º–µ–Ω—Ç–∏
        const modelStatus = document.getElementById('modelStatus');
        const folderBtn = document.getElementById('folderBtn');
        const logDiv = document.getElementById('log');
        const progressFill = document.getElementById('progressFill');
        const processingArea = document.getElementById('processingArea');
        const totalCountSpan = document.getElementById('totalCount');
        const processedCountSpan = document.getElementById('processedCount');
        const viewResultsBtn = document.getElementById('viewResultsBtn');
        const filterGrid = document.getElementById('filterGrid');
        
        // Loaders
        const loadingSection = document.getElementById('loadingSection');
        const loadName = document.getElementById('loadName');
        const loadPct = document.getElementById('loadPct');
        const loadBar = document.getElementById('loadBar');

        let objectDetector = null;
        let imageCaptioner = null;
        let translator = null;
        
        // –ù–∞–±—ñ—Ä –¥–æ–∑–≤–æ–ª–µ–Ω–∏—Ö –∫–ª–∞—Å—ñ–≤ (–∞–Ω–≥–ª—ñ–π—Å—å–∫–æ—é)
        const allowedClasses = new Set(Object.keys(COCO_LABELS));

        function log(msg) {
            logDiv.textContent += `> ${msg}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        // --- –ì–ï–ù–ï–†–ê–¶–Ü–Ø –ß–ï–ö–ë–û–ö–°–Ü–í ---
        function initFilters() {
            filterGrid.innerHTML = '';
            Object.keys(COCO_LABELS).forEach(key => {
                const labelUkr = COCO_LABELS[key];
                
                const div = document.createElement('div');
                div.className = 'filter-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `chk_${key}`;
                checkbox.checked = true; // –ó–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º –≤—Å—ñ –≤–∫–ª—é—á–µ–Ω—ñ
                checkbox.dataset.classKey = key;

                // –°–ª—É—Ö–∞—á –∑–º—ñ–Ω
                checkbox.addEventListener('change', (e) => {
                    if(e.target.checked) allowedClasses.add(key);
                    else allowedClasses.delete(key);
                });

                const label = document.createElement('label');
                label.htmlFor = `chk_${key}`;
                label.textContent = labelUkr.charAt(0).toUpperCase() + labelUkr.slice(1);

                div.appendChild(checkbox);
                div.appendChild(label);
                filterGrid.appendChild(div);
            });
        }
        initFilters();

        document.getElementById('selectAllBtn').onclick = () => {
            document.querySelectorAll('.filter-item input').forEach(c => { c.checked = true; allowedClasses.add(c.dataset.classKey); });
        };
        document.getElementById('deselectAllBtn').onclick = () => {
            document.querySelectorAll('.filter-item input').forEach(c => { c.checked = false; allowedClasses.delete(c.dataset.classKey); });
        };

        // --- –ó–ê–í–ê–ù–¢–ê–ñ–ï–ù–ù–Ø –ú–û–î–ï–õ–ï–ô ---
        const progressCallback = (data) => {
            if (loadingSection.style.display === 'none') loadingSection.style.display = 'block';
            if (data.status === 'initiate') {
                loadName.textContent = data.file.split('/').pop();
                loadPct.textContent = '...';
                loadBar.style.width = '0%';
            } else if (data.status === 'progress') {
                if (data.total) {
                    const p = (data.loaded / data.total) * 100;
                    loadPct.textContent = p.toFixed(0) + '%';
                    loadBar.style.width = p + '%';
                }
            } else if (data.status === 'done') {
                loadBar.style.width = '100%';
            }
        };

        async function loadModels() {
            try {
                loadingSection.style.display = 'block';
                
                modelStatus.textContent = "‚è≥ 1/3: –î–µ—Ç–µ–∫—Ç–æ—Ä (YOLOS)...";
                objectDetector = await pipeline('object-detection', 'Xenova/yolos-tiny', { progress_callback: progressCallback });

                modelStatus.textContent = "‚è≥ 2/3: –û–ø–∏—Å —Å—Ü–µ–Ω–∏ (ViT-GPT2)...";
                imageCaptioner = await pipeline('image-to-text', 'Xenova/vit-gpt2-image-captioning', { progress_callback: progressCallback });

                modelStatus.textContent = "‚è≥ 3/3: –ü–µ—Ä–µ–∫–ª–∞–¥–∞—á (NLLB)...";
                translator = await pipeline('translation', 'Xenova/nllb-200-distilled-600M', { dtype: 'q8', progress_callback: progressCallback });

                loadingSection.style.display = 'none';
                modelStatus.innerHTML = '‚úÖ <b>–ì–æ—Ç–æ–≤–æ!</b> –û–±–µ—Ä—ñ—Ç—å –ø–∞–ø–∫—É –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É.';
                modelStatus.style.color = '#059669';
                folderBtn.disabled = false;

            } catch (err) {
                loadingSection.style.display = 'none';
                modelStatus.textContent = '‚ùå –ü–æ–º–∏–ª–∫–∞: ' + err.message;
            }
        }
        loadModels();

        // --- –û–ë–†–û–ë–ö–ê ---
        folderBtn.addEventListener('click', async () => {
            if (!window.showDirectoryPicker) { alert("Use Chrome/Edge."); return; }
            try {
                const dirHandle = await window.showDirectoryPicker();
                const opts = { mode: 'readwrite' };
                if ((await dirHandle.queryPermission(opts)) !== 'granted') if ((await dirHandle.requestPermission(opts)) !== 'granted') return;

                processingArea.style.display = 'block';
                folderBtn.disabled = true;

                const processedDirHandle = await dirHandle.getDirectoryHandle('processed_fixed', { create: true });
                const images = [];
                for await (const entry of dirHandle.values()) if (entry.kind === 'file' && entry.name.match(/\.(jpg|jpeg|png|webp)$/i)) images.push(entry);

                totalCountSpan.textContent = images.length;
                let processedCount = 0;
                const jsonResults = [];
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                for (const fileHandle of images) {
                    const file = await fileHandle.getFile();
                    const url = URL.createObjectURL(file);
                    try {
                        log(`üì∏ ${file.name}`);
                        const img = new Image();
                        await new Promise((r, e) => { img.onload = r; img.onerror = e; img.src = url; });

                        // 1. –û–ø–∏—Å
                        const capRes = await imageCaptioner(url);
                        const engDesc = capRes[0].generated_text;
                        const transRes = await translator(engDesc, { src_lang: 'eng_Latn', tgt_lang: 'ukr_Cyrl' });
                        const ukrDesc = transRes[0].translation_text;
                        log(`   üìù ${ukrDesc}`);

                        // 2. –î–µ—Ç–µ–∫—Ü—ñ—è
                        const detRes = await objectDetector(url, { threshold: 0.5, percentage: true });

                        // 3. –ú–∞–ª—é–≤–∞–Ω–Ω—è
                        canvas.width = img.width; canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        ctx.lineWidth = 3; ctx.font = 'bold 20px sans-serif'; ctx.textBaseline = 'top';

                        const processedObjects = [];

                        for (const obj of detRes) {
                            const { box, label, score } = obj;
                            
                            // –§–Ü–õ–¨–¢–†: –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ, —è–∫—â–æ –∫–ª–∞—Å –Ω–µ –≤—ñ–¥–º—ñ—á–µ–Ω–∏–π
                            if (!allowedClasses.has(label)) continue;

                            // !!! –í–ò–ü–†–ê–í–õ–ï–ù–ù–Ø –ö–û–û–†–î–ò–ù–ê–¢ !!!
                            let { xmax, xmin, ymax, ymin } = box;
                            // –Ø–∫—â–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –Ω–æ—Ä–º–∞–ª—ñ–∑–æ–≤–∞–Ω—ñ (0-1), –º–∞—Å—à—Ç–∞–±—É—î–º–æ —ó—Ö
                            if (xmax <= 1.05 && ymax <= 1.05) { 
                                xmin *= img.width; xmax *= img.width;
                                ymin *= img.height; ymax *= img.height;
                            }

                            // –ü–µ—Ä–µ–∫–ª–∞–¥ –Ω–∞–∑–≤–∏ (–∑ –Ω–∞—à–æ–≥–æ —Å–ª–æ–≤–Ω–∏–∫–∞, —Ü–µ –º–∏—Ç—Ç—î–≤–æ)
                            const labelUkr = COCO_LABELS[label] || label;

                            const hue = (label.length * 50) % 360;
                            const color = `hsl(${hue}, 90%, 50%)`;

                            // –†–∞–º–∫–∞
                            ctx.strokeStyle = color; ctx.setLineDash([8, 4]);
                            ctx.strokeRect(xmin, ymin, xmax - xmin, ymax - ymin);
                            
                            // –¢–µ–∫—Å—Ç
                            ctx.setLineDash([]); ctx.fillStyle = color;
                            const txtW = ctx.measureText(labelUkr).width;
                            
                            // –©–æ–± —Ç–µ–∫—Å—Ç –Ω–µ –≤–∏–ª—ñ–∑ –∑–∞ –≤–µ—Ä—Ö
                            let txtY = ymin - 28;
                            if (txtY < 0) txtY = ymin; 

                            ctx.fillRect(xmin, txtY, txtW + 10, 28);
                            ctx.fillStyle = 'white'; ctx.fillText(labelUkr, xmin + 5, txtY + 4);

                            processedObjects.push({ label: labelUkr, label_en: label, box: { xmin, ymin, xmax, ymax } });
                        }

                        // –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è
                        const blob = await new Promise(r => canvas.toBlob(r, file.type));
                        const newFileHandle = await processedDirHandle.getFileHandle(file.name, { create: true });
                        const writable = await newFileHandle.createWritable();
                        await writable.write(blob); await writable.close();

                        jsonResults.push({ filename: file.name, description: ukrDesc, objects: processedObjects });

                    } catch (e) { log(`‚ùå Error: ${e.message}`); } 
                    finally { 
                        URL.revokeObjectURL(url); processedCount++; 
                        processedCountSpan.textContent = processedCount;
                        progressFill.style.width = `${(processedCount / images.length) * 100}%`;
                    }
                }

                const jsonHandle = await dirHandle.getFileHandle('results_fixed.json', { create: true });
                const writable = await jsonHandle.createWritable();
                await writable.write(JSON.stringify(jsonResults, null, 2)); await writable.close();

                log("üéâ –ó–ê–í–ï–†–®–ï–ù–û!"); folderBtn.textContent = "–£—Å–ø—ñ—à–Ω–æ!"; folderBtn.classList.add('success');
                viewResultsBtn.style.display = 'inline-block';

            } catch (err) { console.error(err); folderBtn.disabled = false; }
        });

        // Modal
        const modal = document.getElementById('resultModal');
        viewResultsBtn.onclick = async () => {
            const fh = await (await window.showDirectoryPicker()).getFileHandle('results_fixed.json');
            document.getElementById('jsonViewer').value = await (await fh.getFile()).text();
            modal.style.display = 'flex';
        };
        document.getElementById('closeModal').onclick = () => modal.style.display = 'none';
    </script>
</body>
</html>